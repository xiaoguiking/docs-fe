# 前端性能优化



## 职业发展问题
:::details 

```
- 前端工程化
    - 编译打包发布流程
    - 物料中心 
    - 组件化

- 体验领域
  - 性能优化方向
```
:::

## 一、前端性能优化方法论

### 1.1 从页面输入到页面加载的全过程

- 客户端发起请求阶段
  - 本地缓存
    - 强缓存 (根据请求头的expires 和 cache-control 判断是否命中客户端缓存)
    - 协商缓存 (浏览器先发送一个请求到服务器通过last-modified和etag验证资源是否命中客户端缓存)
  -  DNS查询
     -  配置DNS查询走缓存
  -  Http 请求阻塞
- 服务端数据请求处理阶段
  - 是否增加了Gzip压缩
  - CDN请求
  - 页面重定向
    - 服务端的302重定向
    - META标签实现的重定向
    - window.location实现的重定向
- 客户端页面渲染阶段
  - DOM树构建过程
  - CSSOM树构成生成过程
  - 重排和重绘过程

### 1.2 移动端M站性能优化

- 项目立项
- 性能诊断优化
  - 本地缓存减少请求资源数
  - 运维对静态资源配置合理的资源过期时间，实现静态资源的强缓存方案 
  -
- 重点难点
  - 1. 列表页改单页面应用
    - 1. 列表页主要用来展示分类下的列表信息，根据用户的筛选项，将搜索结果展示给用户
    - 2. 爬虫SEO, 页面访问头是爬虫就走服务端模版，个人用户就走单页面应用
  - 2. 弱网下的优化
    - 1. 页面请求合并处理
    - 2. 小图标使用base64处理，内嵌在页面中
    - 3. 针对弱网，不自动加载请求，使用展位图
  - 主要是由点到面的处理，先局部后整体

### 1.3 首屏时间指标采集办法

- 手动采集
  - 埋点
- 通用采集
  - 使用配置类型代码处理
- 服务端模版下的采集办法
  - HTTP请求
  - HTML文档加载解析完成
    - 首屏时间点 DOMContentLoad
      - 当页面中的html加载解析完成之后DOMContentLoaded事件触发
      - 首屏时间 = DOMContentLoad时间 = domContentLoadEventEd - fetchStart时间
  - 加载样式和脚本文件
  - 完成页面渲染
- 单页面应用业务下的采集办法
  - 在用户进入页面，使用MutationObserver监控DOM元素，当DOM元素发生变化，程序会标记元素的元素记录时间点和分数，存储到数组中


### 1.4 白屏、卡顿等指标采集办法
 
> 白屏:
> 从输入页面内容回车包括刷新、跳转等方式后到页面开始出现的第一个字符的时间

> 白屏时间 = 页面开始展示时间 - 开始请求时间点
> 白屏时间FP = domLoading - navigationStart

> 卡顿指标采集：
> FPS 每秒显示帧数


为什么会出现APP白屏时间过长或卡顿问题 ？

```
一般WebView初始化慢、DNS解析慢、视图树过于复杂和主线程被阻塞等都会导致问题出现
大多数白屏和卡顿都和网络环境有关
```



> 浏览器页面加载过程

```
1. 客户端发起请求
2. 下载html、css、js资源
3. 解析js执行
4. js请求数据
5. 客户端解析DOM并渲染
6. 下载渲染图片
7. 完成渲染整体
```

> APP 下的页面加载过程

```
1. 初始化WebView  
2. 客户端发起请求
3. 下载html及JS/CSS资源
4. 解析JS执行
5. JS请求数据
6. 服务端处理并返回数据
7. 客户端解析DOM并渲染
8. 下载渲染图片
9. 完成整体渲染
```



## 二、指标采集上报优化手段

### 性能SDK以及上报策略设计

1.为了进行首屏、白屏、卡顿的指标采集

```
封装Perf API
调用FMP、FP、Block、ExtensionAPI完成

调用window api 接口需要处理环境兼容
```


### 前端性能平台搭建

- 平台层
  - React Antd Antv 
- 数据接入层
  - NodeJs Node-sechdule Node-mailer 
- 数据计算层
  - Kafka Spark hive HDFS
- 存储层 
  - Mysql Mongodb

> 性能平台架构设计流程

> 1. 数据处理后台

```
1. 客户端借助SDK上报性能数据指标，使用Nodejs利用Controller层对数据做处理，将SDK上报的数据通过URL解析成key-value格式的数据进行空数据删除，异常数据舍弃等操作 

2. 对Kafka中的数据进行清洗和计算(重复数据、缺失数据、错误数据)

3. 使用Spark做数据计算，为可视化数据做准备(首屏时间的分步计算、 秒开率计算首屏时间小于等于1秒的数据占比 页面瀑布流时间计算)

4. mysql存储用户关注的信息登录， mongodb存入性能数据

```

> 2. 前端数据可视化展示前台

```
1. 性能可视图前端展示
2. 监控预警问题，借助Node-sechdule做调度，和定时任务的处理，使用node-mailer邮件报警
```

```
最重要的指标： 秒开率、首屏时间、白屏时间、卡顿时间
```

### 监控预警以及问题诊断

- 监控预警
  - 准备预警数据
    - 数据清洗后，一个分支使用Spark计算
    - 使用Flink做实时数据计算
    - 对数据分层，标记预警数据
  -  数据拉取
    - 使用Node-schedule定时任务将预警数据通过Nodejs拉取数据到MongoDB预警表中
  -  数据预警
     -  根据预警数据的不同，预警内容分级别预警给开发关注者


### 如何处理首屏秒开


#### 懒加载

> 懒加载是长页面加载过程时先加载关键内容，延迟加载非关键内容

#### 缓存

> 缓存是二次访问时，直接从缓存中获取数据，不进行网络请求，提升页面加载速度，降低服务器压力

- native 接口请求，已经请求过的接口不会再请求
  - native缓存过程
    - 1. 查看app本地是否有缓存
    - 2. 如果有缓存，直接使用缓存数据
    - 3. 没有，发起请求，请求成功后，将数据存入本地缓存
- H5接口请求，需要等webview加载完成过后，才会发起请求
- 静态资源缓存
  - 长时间不变的静态资源，使用强缓存通过cache-control和expires设置缓存时间
  - etag 设置协商缓存

#### 离线化

> 离线化： 把页面内容静态化到本地，离线化一般适合首页或者列表页不需要登录的场景，同时支持SEO功能
> 使用prerender-spa-plugin插件，将页面静态化，通过服务端渲染，将页面内容渲染成html，通过服务端返回给客户端


#### 并行化

> 并行化： 将页面内容分成多个部分，同时发起请求，提升页面加载速度

- HTTP 1.1时代性能瓶颈 串行的文件传输和同域名的连接数限制(6个)
- HTTP 2.0时代，多路复用，首部压缩，服务器推送，并行化传输 使用帧和流的方式传输

### 白屏300ms和界面优化流畅手段

- DNS查询
  - DNS查询是指浏览器发起请求需要将用户输入的域名转换为ip地址的过程
    ```html
    1.前端侧：在页面中加入dns-prefetch
    <meta http-eqiv=“x-dns-prefetch-control” content="on" /> // 开启dns预解析
    <link rel="dns-prefetch" href="https://s.google.com/" >  // 对xxx域名解析


    2.客户端侧： 可以再启动App时候，同步创建一个不可见的webview
    将常用的静态资源路径写入这个webview中，然后对它域名做解析放入缓存中，这样后面需要使用webview打开真正所需的页面，由于已经做过域名解析，直接从缓存中读取即可

    如果是端外页面可以使用iframe，也能达到类似效果
    ```
- 首字符展示 
  - loading优化展示加载数据中
  - 骨架屏是在页面数据加载完成前先给用户展示出页面的大致结构（灰色展位图）告诉用户页面正在渐进式加载，然后在渲染出实际页面后，把对应结构替换掉


#### 卡顿治理

> 卡顿现象一般可以通过用户反馈或性能平台发现，在性能平台查看卡顿指标后，发现页面连续5帧超过50ms，属于严重卡顿


- 如何处理
  - 首先定位问题
  - 如果是数据问题，找后端人员或者缓存处理



## 三、Hybrid下的进阶优化 

###  Hybrid 优化整体分析

- App启动阶段的优化方案
  - 使用webview全局优化，启动一个webview保存在全局资源池，当用户访问网页，从公共资源池加载
- 页面白屏阶段优化方案
  - 使用离线包: 将前端静态资源打包到一个压缩包内，app预先内置该压缩包到本地，然后当用户在客户端打开h5，直接从本地加载
  - 离线包更新问题：可以生成离线包的同时，生成一个配置文件让App先根据这个静态文件判断是需要更新离线包还是直接发起请求
  - 使用SSR服务端渲染方式
  - 骨架屏
- 首屏渲染阶段优化
  - 客户端代理数据接口请求(在客户端初始化webview的同事，直接由native发起网络请求 h5页面初始化完成后直接通过SDK向native获取数据)
  - 根据页面场景选择预加载(滚动下拉列表页面，根据用户滚动条的位置，提前加载一页的展示，这样用户滚动过程，就会流畅)
- 旅行App，服务端根据用户操作路径，判断打开搜索结果页的概率，超过阈值，预先请求
  





